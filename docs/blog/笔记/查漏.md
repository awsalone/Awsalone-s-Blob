### 1

读到这里，可能有些人会说，我之前待的都是一些小公司，业务简单，项目都不难，没啥可写的。但你有没有想过，你每天的开发工作，有没有痛点或者不爽的地方？比如经常通过 CV 大法拷贝代码， 你有想过抽离和复用这些模块吗？公共 JS 模块的共享，你是通过拷贝代码，还是自己搭一个 NPM 私服？所有项目都放在一个 repo 下，编译打包速度慢，有没有想过拆成 multiple repo 或者是 mono repo？开发上线流程不规范，有没有想过参考一些业内成熟的方案搭建一套 CI/CD 方案呢？使用一些开源库遇到问题，你是去百度或者等着别人去解决，还是自己研究源码然后去提个 PR 呢？

### 2

“从输入 URL 到页面渲染中间发生什么” 这是一个老生常谈的问题，有些候选人回答这个问题感觉一看就是准备过的，但是一细问都会露馅，比如 TCP 的三次握手，每次发了回了什么样的包？浏览器解析文档过程中，遇到外链的 JS，会不会阻塞渲染，遇到外链的 CSS，会不会阻塞渲染，如果阻塞了，原因是什么，如果没阻塞，原因又是什么？



### token和cookie

token，令牌，多用户下的处理验证；

* 客户端发送uername，pwd登录，服务端通过登录校验则生成token返回
* 客户端收到token保存在客户端
* 每次访问api，header携带token
* 服务端通过采用filter过滤器校验。校验成功返回数据，失败返回错误码

优势：

* 安全性：不再发送cookie，避免了scrf攻击；只起到存储机制，而非校验；有时效性
* 可扩展性：可以提供可选的权限给第三方应用程序；能创建和其他程序共享权限的程序
* 多平台跨域



cookie

浏览器状态管理的一个文件

浏览器中永久存储的一种数据；浏览器把cookie以kv形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。



session

服务器要知道当前发请求给自己的是谁。为了做这种区分，服务器就要给每个客户端分配不同的“身份标识”，然后客户端每次向服务器发请求的时候，都带上这个“身份标识”，服务器就知道这个请求来自于谁了。至于客户端怎么保存这个“身份标识”，可以有很多种方式，对于浏览器客户端，大家都默认采用 cookie 的方式。

服务器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。这种用户信息存储方式相对cookie来说更安全，可是session有一个缺陷：如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失。



### [].push.apply(variable,arguments)

借用数组方法push，利用apply特性，可以将arguments依次传入variable中，可以处理数组中传入数组



### toPrimitive()函数

toPrimitive（input,preferedType?）

若省略preferedType，此时，日期会被认为是字符串，而其他的值会被当做Number。

将对象转换为基本类型时，会调用toPrimitive（）。

tostring：返回一个反应这个对象的字符串；valueof：返回它相应的原始值

转换的类型是number

1. 若input是原始值，直接返回
2. else if input 是对象，调用input.valueOf(),如果结果是原始值，返回结果；
3. else if input.toString()如果结果是原始值，返回结果
4. else ，抛出错误

转换的类型是string,2和3交换

若只重写tostring或valueof其中一种方法，转换时优先使用重写的方法



## 安全

### XSS攻击

#### 什么是XSS

Cross-Site Scripting(跨站脚本攻击)，一种代码注入攻击。攻击者通过在目标网站注入恶意脚本，使之在用户浏览器上运行。利用这些恶意脚本获取用户的敏感信息如Cookie、SessionID等，进而危害数据安全。



常见注入方法：

* 在 HTML 中内嵌的文本中，恶意内容以 script 标签形成注入。

* 在内联的 JavaScript 中，拼接的数据突破了原本的限制（字符串，变量，方法名等）。
* 在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签。
* 在标签的 href、src 等属性中，包含 `javascript:` (伪协议)等可执行代码。
* 在 onload、onerror、onclick 等事件中，注入不受控制代码。
* 在 style 属性和标签中，包含类似 `background-image:url("javascript:...");` 的代码（新版本浏览器已经可以防范）。
* 在 style 属性和标签中，包含类似 `expression(...)` 的 CSS 表达式代码（新版本浏览器已经可以防范）。

#### XSS攻击的分类

根据攻击来源，XSS攻击分为存储型、反射型和DOM型三种。

存储型：将恶意代码提交到目标网站数据库中

反射型：构造出特殊URL，其中包含恶意代码

前两者属于服务端安全漏洞，DOM型取出和执行恶意代码由浏览器端完成，属于前端js自身安全漏洞。

DOM型：

1. 攻击者构造特殊URL，其中包含恶意代码
2. 用户打开带恶意代码的URL
3. 用户浏览器接收到响应后解析执行，前端js取出URL中恶意代码并执行
4. 恶意代码窃取用户数据并发送到攻击者网站，或冒充用户行为，调用目标网站接口执行攻击者指定操作



#### 预防DOM型XSS攻击

在使用 `.innerHTML`、`.outerHTML`、`document.write()` 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 `.textContent`、`.setAttribute()` 等。

如果用 Vue/React 技术栈，并且不使用 `v-html`/`dangerouslySetInnerHTML` 功能，就在前端 render 阶段避免 `innerHTML`、`outerHTML` 的 XSS 隐患。

DOM 中的内联事件监听器，如 `location`、`onclick`、`onerror`、`onload`、`onmouseover` 等，`<a>` 标签的 `href` 属性，JavaScript 的 `eval()`、`setTimeout()`、`setInterval()` 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。



### CSRF跨站点请求伪造

#### 什么是CSRF

跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。如:攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

![简而言之：网站过分相信用户](https://user-gold-cdn.xitu.io/2019/2/21/1690e0ca6c93e74a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



### CSRF的特点

- 攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。
- 攻击**利用受害者在被攻击网站的登录凭证，冒充受害者提交操作**；而不是直接窃取数据。
- 整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。
- 跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。

CSRF通常是跨域的，因为外域通常更容易被攻击者掌控。但是如果本域下有容易被利用的功能，比如**可以发图和链接的论坛和评论区，攻击可以直接在本域下进行，而且这种攻击更加危险。**



### CSRF与 XSS 区别

- **通常来说 CSRF 是由 XSS 实现的，CSRF 时常也被称为 XSRF（CSRF 实现的方式还可以是直接通过命令行发起请求等）。**

- 本质上讲，XSS 是代码注入问题，**CSRF 是 HTTP 问题。** XSS 是内容没有过滤导致浏览器将攻击者的输入当代码执行。**CSRF 则是因为浏览器在发送 HTTP 请求时候自动带上 cookie，而一般网站的 session 都存在 cookie里面(Token验证可以避免)。**

  

这里存在一个问题：cookie也是受到同源策略限制的，两个不同源的网站其中一个应该是不会让另一个获得自己的cookie的，那为什么CSRF攻击仍然有效？

 答：

1. 除了跨域 XHR 请求情况下，浏览器在发起请求的时候会把符合要求的 cookie 自动带上 (涉及：域名，有效期，路径，secure 属性)
2. 跨域 XHR 的请求的情况下，也可以携带 cookie
3. 浏览器允许跨域提交表单

cookie是可以跨域的，且在某些跨域情况下，浏览器中有页面或网站向某个域名发送请求时，其请求都会**自动**带上该域名下的所有满足条件的 cookie

 

总而言之，虽然说如果没有同源策略CSRF会更猖狂，但是同源策略阻止不了CSRF，同源策略确实是会拦截某些（不是全部）请求后的HTTP回复（而不是禁止请求执行），有些请求是可以跨域且附带cookie的，还有些情况下你啪的一下子请求成功发出去了，这次的攻击就完成了，后端程序已经执行了，是否有回复已经不重要了

 

### 防御

- 验证码；强制用户必须与应用进行交互，才能完成最终请求。此种方式能很好的遏制 csrf，但是用户体验比较差。

- Referer check；请求来源限制，此种方法成本最低，但是并不能保证 100% 有效，因为服务器并不是什么时候都能取到 Referer，而且低版本的浏览器存在伪造 Referer 的风险。

- token；**token 验证的 CSRF 防御机制是公认最合适的方案。若网站同时存在 XSS 漏洞的时候，这个方法也是空谈。**CSRF还是因为服务器无法判断当前的请求是否是合法用户的自定义操作

  所以抵御CSRF的关键在于在正常请求中加上一些攻击者不能伪造的东西，且其不存在于cookie，灵魂发问如何证明你是你

  于是可以在HTTP请求中单独加入一个参数---一个随机生成的令牌---token

  服务器在用户登录后，会给用户一个唯一的合法令牌，每次操作都会对此令牌进行校验



对于来自黑客自己的网站，我们无法防护。但对其他情况，那么如何防止自己的网站被利用成为攻击的源头呢？

- 严格管理所有的上传接口，防止任何预期之外的上传内容（例如HTML）。
- 添加Header `X-Content-Type-Options: nosniff` 防止黑客上传HTML内容的资源（例如图片）被解析为网页。
- 对于用户上传的图片，进行转存或者校验。不要直接使用用户填写的图片链接。
- 当前用户打开其他用户填写的链接时，需告知风险（这也是很多论坛不允许直接在内容中发布外域链接的原因之一，不仅仅是为了用户留存，也有安全考虑）。



### 总结

- CSRF自动防御策略：同源检测（Origin 和 Referer 验证）。
- CSRF主动防御措施：Token验证 或者 双重Cookie验证 以及配合Samesite Cookie。
- 保证页面的幂等性，后端接口不要在GET页面中做用户操作。

为了更好的防御CSRF，最佳实践应该是结合上面总结的防御措施方式中的优缺点来综合考虑，结合当前Web应用程序自身的情况做合适的选择，才能更好的预防CSRF的发生。



参考链接[https://juejin.cn/post/6844903781704925191]

xss小游戏：

[alert(1) to win](https://alf.nu/alert1) [prompt(1) to win](http://prompt.ml/) [XSS game](https://xss-game.appspot.com/)





## 位操作符

#### 按位非 ~

运算结果为-(x+1),过程：32位二进制取反



#### 按位与 &

两位均是1时返回1，否则返回0



#### 按位或 |

至少一位是1时返回1，两位都是0时返回0 



#### 按位异或^

两位都是1或0返回0，两位不同返回1



#### 左移 <<

按指定位数，将数值所有位往左移动，左移会以 0 填充这些空位（会保留符号）



#### 无符号右移 >>>

与有符号右移不同，无符号右移会给空位补 0，而不管符号位是什么。对正数来说，这跟有符号右移效果相同。但对负数来说，结果就差太多了。无符号右移操作符将负数的二进制表示当成正数的二进制表示来处理。因为负数是其绝对值的二补数，所以右移之后结果变得非常之大



#### 有符号右移 >>

会将数值的所有 32 位都向右移，同时保留符号,右移后空位会出现在左侧，且在符号位之后。ECMAScript 会用符号位的值来填充这些空位，以得到完整的数值。

