## XSS攻击

#### 什么是XSS
即Cross-Site Scripting(跨站脚本攻击)，一种代码注入攻击。攻击者通过在目标网站注入恶意脚本，使之在用户浏览器上运行。利用恶意脚本获取用户敏感信息如Cookie、SessionID等，进而危害数据安全

#### 常见注入方法：
* 在 HTML 中内嵌的文本中，恶意内容以 script 标签形成注入。
* 在内联的 JavaScript 中，拼接的数据突破了原本的限制（字符串，变量，方法名等）。
* 在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签。
* 在标签的 href、src 等属性中，包含 `javascript:` (伪协议)等可执行代码。
* 在 onload、onerror、onclick 等事件中，注入不受控制代码。
* 在 style 属性和标签中，包含类似 `background-image:url("javascript:...");` 的代码（新版本浏览器已经可以防范）。
* 在 style 属性和标签中，包含类似 `expression(...)` 的 CSS 表达式代码（新版本浏览器已经可以防范）。

#### XSS攻击的分类

根据攻击来源，XSS攻击分为存储型、反射型和DOM型三种。

存储型：将恶意代码提交到目标网站数据库中。

反射型：构造出特殊URL，其中包含恶意代码，恶意代码存在 URL 里。

前两者属于服务端安全漏洞，DOM型取出和执行恶意代码由浏览器端完成，属于前端js自身安全漏洞。

DOM型：

1. 攻击者构造特殊URL，其中包含恶意代码
2. 用户打开带恶意代码的URL
3. 用户浏览器接收到响应后解析执行，前端js取出URL中恶意代码并执行
4. 恶意代码窃取用户数据并发送到攻击者网站，或冒充用户行为，调用目标网站接口执行攻击者指定操作

#### 预防DOM型XSS攻击

在使用 `.innerHTML`、`.outerHTML`、`document.write()` 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 `.textContent`、`.setAttribute()` 等。

如果用 Vue/React 技术栈，并且不使用 `v-html`/`dangerouslySetInnerHTML` 功能，就在前端 render 阶段避免 `innerHTML`、`outerHTML` 的 XSS 隐患。

DOM 中的内联事件监听器，如 `location`、`onclick`、`onerror`、`onload`、`onmouseover` 等，`<a>` 标签的 `href` 属性，JavaScript 的 `eval()`、`setTimeout()`、`setInterval()` 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。


## CSRF跨站点请求伪造

#### 什么是CSRF
跨站请求伪造（Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。如:攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

下图引自浅谈CSRF攻击方式
![简而言之：网站过分相信用户](https://user-gold-cdn.xitu.io/2019/2/21/1690e0ca6c93e74a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

#### CSRF特点
- 攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。
- 攻击**利用受害者在被攻击网站的登录凭证，冒充受害者提交操作**；而不是直接窃取数据。
- 整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。
- 跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。

CSRF通常是跨域的，因为外域通常更容易被攻击者掌控。但是如果本域下有容易被利用的功能，比如**可以发图和链接的论坛和评论区，攻击可以直接在本域下进行，而且这种攻击更加危险。**

#### CSRF与 XSS 区别

- **通常来说 CSRF 是由 XSS 实现的，CSRF 时常也被称为 XSRF（CSRF 实现的方式还可以是直接通过命令行发起请求等）。**

- 本质上讲，XSS 是代码注入问题，**CSRF 是 HTTP 问题。** XSS 是内容没有过滤导致浏览器将攻击者的输入当代码执行。**CSRF 则是因为浏览器在发送 HTTP 请求时候自动带上 cookie，而一般网站的 session 都存在 cookie里面(Token验证可以避免)。**

这里有个疑问，cookie受同源策略限制，不同网站之间应该无法获取到对方网站的cookie，为什么CSRF攻击仍然有效？
答：浏览器已经限制跨域的cookie使用,这只是针对XHR,下面的情况都可以正常使用cookie(Cookie 的 SameSite 属性 为默认情况下,具体可以看此属性对跨域限制)
1. 直接通过window.location.href=xxx 重定向跨域
2. 通过<form> 表单跨域提交 ,不论post 或者get
3. 通过<ifram> 打开跨域连接

所以同源策略没有完全限制跨域攻击的可能,要完全限制只能要求网页不能跳外链或者任何外链都不能带cookie,这样做成本会很重会严重影响网站功能开发

除了跨域 XHR 请求情况下，浏览器在发起请求的时候会把符合要求的 cookie 自动带上 (涉及：域名，有效期，路径，secure 属性)

 #### 防御
 - 验证码：强制用户必须与应用进行交互，才能完成最终请求。此种方式能很好的遏制 csrf，但是用户体验比较差。

- Referer check：HTTP请求头中包含Referer字段表示请求来源，告诉服务器我是从哪个链接来的，如果是从恶意网站发出的请求Referer字段不会是正常的请求来源。这部分的校验是在后台代码中编写的

- Origin：与Referer思想类似，但区别在于Origin只存在于同域的post请求（Referer存在于所有类型请求）或者某些跨域情形（比如CORS跨域）中（如果浏览器不能获得请求源，但是满足这俩条件，也会携带Origin只不过值为null），且只包含是谁（哪个源）发出的请求（origin包括协议和域名还有端口；referer除此之外还有路径和查询参数），没有太多的信息，隐私方面好些。。。

- token：**token 验证的 CSRF 防御机制是公认最合适的方案。若网站同时存在 XSS 漏洞的时候，这个方法也是空谈。**CSRF还是因为服务器无法判断当前的请求是否是合法用户的自定义操作

  所以抵御CSRF的关键在于在正常请求中加上一些攻击者不能伪造的东西，且其不存在于cookie，灵魂发问如何证明你是你

  于是可以在HTTP请求中单独加入一个参数---一个随机生成的令牌---token

  服务器在用户登录后，会给用户一个唯一的合法令牌，每次操作都会对此令牌进行校验

- samesite：专门用来防止CSRF。有三个属性值：Strict、Lax、None
Strict：最严格，完全禁止第三方cookie　，跨站时任何情况下都不会发送cookie，只有同站请求允许携带cookie（例如在一个网站中有一个链接，点击会跳转到GitHub上，在设置了strict的情况下，GitHub永远都是未登录状态）
Lax：一般严格，大多数情况下不发送第三方cookie，导航到目标网址的GET请求除外，导航到目标网址的GET请求只包括三种情况：链接、预加载请求、GET表单，即除了同站请求允许携带cookie之外也有特定的情况允许携带cookie
 None：关闭samesite属性（前提是必须同时设置Secure属性，否则无效），同站跨站请求都可以携带cookie
兼容问题：仅在新版Chrome和Firefox支持
致命的缺陷：不支持子域。


对于来自黑客自己的网站，我们无法防护。但对其他情况，那么如何防止自己的网站被利用成为攻击的源头呢？

- 严格管理所有的上传接口，防止任何预期之外的上传内容（例如HTML）。
- 添加Header `X-Content-Type-Options: nosniff` 防止黑客上传HTML内容的资源（例如图片）被解析为网页。
- 对于用户上传的图片，进行转存或者校验。不要直接使用用户填写的图片链接。
- 当前用户打开其他用户填写的链接时，需告知风险（这也是很多论坛不允许直接在内容中发布外域链接的原因之一，不仅仅是为了用户留存，也有安全考虑）。

