## 进程和线程
进程 cpu资源分配的最小单位，进程之间相互独立（可大代价实现通信）
线程 cpu调度的最小单位，进程的基础上运行，一个进程可有多个线程

# 网络协议
## OSI,TCP/IP

OSI七层网络协议 ： 应用层、表示层、会话层、传输层、网络层、数据链路层、物理层

OSI五层网络协议： 应用层                                       传输层、网络层、数据链路层、物理层

TCP/IP：                   应用层												传输层（TCP/UDP）、网际层、网络接口层



1. 应用层：直接为应用进程提供服务。应用层协议定义的是应用进程间通信和交互的规则，不同应用有不同的应用层协议

2. 传输层： 负责两台主机中的进程提供通信服务。

   传输控制协议（TCP）：提供面向连接的、可靠的数据传输服务，数据传输的基本单位是报文段。（可靠传输：1.确认机制 2.重传输  3.重排序 ）

   用户数据报协议（UDP）：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性，数据传输的基本单位是用户数据报。（无ACK  无seq）

3. 网络层（网际层）：负责为两台主机提供通信服务，并通过选择合适的路由将数据传递到目标主机

4. 数据链路层：负责将网络层交下来的IP数据报封装成帧，并在链路的相邻节点间传送帧，每一帧包含数据和必要的控制信息。

5. 物理层：切包数据在各种物理媒介上进行传输，为数据传输提供可靠的环境

## TCP/IP三次握手四次挥手
三次握手：
* 客户端向服务端发送SYN报文,并指明初始化序列号ISN，客户端closed->SYN-SENT状态
* 服务端接收到客户端SYN报文后，返回自己的SYN报文，并指定自己的ISN，同时将客户端的ISN+1作为ACK返回客户端，表示自己收到了客户端的SYN，服务器从listen->SYN-RCVD
* 客户端接收到SYN报文后，发送ACK报文，表示收到客户端的SYN，客户端进入ESTABLISHED状态，服务端收到ACK报文后，也处于ESTABLISED状态，双方建立连接

四次挥手：
* 第一次 客户端发送FIN报文，报文中指定一个序列号，客户端进入FIN-WAIT-1状态。这是客户端同时也变成了half-close状态，即无法向服务端发送报文，只能接受。
* 第二次 服务端接收到FIN报文，会发送ACK报文，且把接受到的序列号+1作为ACK报文的序列号值，表示接受到报文，服务器进入CLOSE_WAIT状态，通知自身关闭连接
* 客户端接收到服务端的ACK，进入FIN-WAIT-2状态
* 第三次 如果服务端也想断开连接了，和客户端第一次挥手一样，发送FIN报文，且指定一个序列号。服务端进入LAST-ACK状态
* 第四次 客户端接收到FIN，一样发送ACK报文作为应答，此时客户端进入TIME-WAIT状态

此时客户端等待2个MSL（最大报文生存时间），这段时间内如果客户端没有接受到服务端的重发请求，表示ACK成功到达，挥手结束，否则服务端重发ACK

1. 为什么要三次握手，两次呢？
  两次握手，服务端不能确定客户端的接收能力

2. 半连接队列？
  服务器端第一次接受到客户端的SYN请求，就会处于SYN-RCVD状态，此时双方没有完全建立连接，服务器会把此种状态下请求连接放在一个队列中，称为半连接队列。

3. SYN攻击？
服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。

检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。

```java
netstat -n -p TCP | grep SYN_RECV
```

常见的防御 SYN 攻击的方法有如下几种：

- 缩短超时（SYN Timeout）时间
- 增加最大半连接数
- 过滤网关防护
- SYN cookies技术

4. **四次挥手释放连接时，等待2MSL的意义?**

- 保证客户端发送的最后一个ACK报文段能够到达服务端。
- 防止“已失效的连接请求报文段”出现在本连接中。

5. **为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？**

理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但是可能网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。

参考  https://juejin.cn/post/6844904070889603085#heading-27

​			https://zhuanlan.zhihu.com/p/86426969