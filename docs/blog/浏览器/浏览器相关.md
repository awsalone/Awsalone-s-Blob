## 进程和线程
进程 cpu资源分配的最小单位，进程之间相互独立（可大代价实现通信）
线程 cpu调度的最小单位，进程的基础上运行，一个进程可有多个线程

# 网络协议
## OSI,TCP/IP

OSI七层网络协议 ： 应用层、表示层、会话层、传输层、网络层、数据链路层、物理层

OSI五层网络协议： 应用层                                       传输层、网络层、数据链路层、物理层

TCP/IP：                   应用层												传输层（TCP/UDP）、网际层、网络接口层



1. 应用层：直接为应用进程提供服务。应用层协议定义的是应用进程间通信和交互的规则，不同应用有不同的应用层协议

2. 传输层： 负责两台主机中的进程提供通信服务。

   传输控制协议（TCP）：提供面向连接的、可靠的数据传输服务，数据传输的基本单位是报文段。（可靠传输：1.确认机制 2.重传输  3.重排序 ）

   用户数据报协议（UDP）：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性，数据传输的基本单位是用户数据报。（无ACK  无seq）

3. 网络层（网际层）：负责为两台主机提供通信服务，并通过选择合适的路由将数据传递到目标主机

4. 数据链路层：负责将网络层交下来的IP数据报封装成帧，并在链路的相邻节点间传送帧，每一帧包含数据和必要的控制信息。

5. 物理层：切包数据在各种物理媒介上进行传输，为数据传输提供可靠的环境

## TCP/IP三次握手四次挥手
三次握手：
* 客户端向服务端发送SYN报文,并指明初始化序列号ISN，客户端closed->SYN-SENT状态
* 服务端接收到客户端SYN报文后，返回自己的SYN报文，并指定自己的ISN，同时将客户端的ISN+1作为ACK返回客户端，表示自己收到了客户端的SYN，服务器从listen->SYN-RCVD
* 客户端接收到SYN报文后，发送ACK报文，表示收到客户端的SYN，客户端进入ESTABLISHED状态，服务端收到ACK报文后，也处于ESTABLISED状态，双方建立连接

四次挥手：
* 第一次 客户端发送FIN报文，报文中指定一个序列号，客户端进入FIN-WAIT-1状态。这是客户端同时也变成了half-close状态，即无法向服务端发送报文，只能接受。
* 第二次 服务端接收到FIN报文，会发送ACK报文，且把接受到的序列号+1作为ACK报文的序列号值，表示接受到报文，服务器进入CLOSE_WAIT状态，通知自身关闭连接
* 客户端接收到服务端的ACK，进入FIN-WAIT-2状态
* 第三次 如果服务端也想断开连接了，和客户端第一次挥手一样，发送FIN报文，且指定一个序列号。服务端进入LAST-ACK状态
* 第四次 客户端接收到FIN，一样发送ACK报文作为应答，此时客户端进入TIME-WAIT状态

此时客户端等待2个MSL（最大报文生存时间），这段时间内如果客户端没有接受到服务端的重发请求，表示ACK成功到达，挥手结束，否则服务端重发ACK

1. 为什么要三次握手，两次呢？
    两次握手，服务端不能确定客户端的接收能力

2. 半连接队列？
    服务器端第一次接受到客户端的SYN请求，就会处于SYN-RCVD状态，此时双方没有完全建立连接，服务器会把此种状态下请求连接放在一个队列中，称为半连接队列。

3. SYN攻击？
服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。

检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。

```java
netstat -n -p TCP | grep SYN_RECV
```

常见的防御 SYN 攻击的方法有如下几种：

- 缩短超时（SYN Timeout）时间
- 增加最大半连接数
- 过滤网关防护
- SYN cookies技术

4. **四次挥手释放连接时，等待2MSL的意义?**

- 保证客户端发送的最后一个ACK报文段能够到达服务端。
- 防止“已失效的连接请求报文段”出现在本连接中。

5. **为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？**

理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但是可能网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。

参考  https://juejin.cn/post/6844904070889603085#heading-27

​			https://zhuanlan.zhihu.com/p/86426969



# 从输入URL到看到页面发生了什么？

* DNS解析
* 发起TCP连接
* 发送HTTP请求
* 服务器处理请求并返回HTTP报文
* 浏览器解析渲染页面
* 断开连接



## DNS解析

即获取所访问的ip地址，先从本地缓存查找，若没有则向上级域名服务器查找



## 发送HTTP请求

### 请求行

请求行的格式为`Method Request-URL HTTP-Version CRLF` `eg: GET index.html HTTP/1.1` 常用的方法有: `GET`,`POST`, `PUT`, `DELETE`, `OPTIONS`, `HEAD`。



#### 常见的请求方法区别（get\post）

* GET在浏览器回退时是无害的，而POST会再次提交请求。
* GET产生的URL地址可以被Bookmark，而POST不可以。
* GET请求会被浏览器主动cache，而POST不会，除非手动设置。
* GET请求只能进行url编码，而POST支持多种编码方式。
* GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
* GET请求在URL中传送的参数是有长度限制的，而POST么有。
* 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
* GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
* GET参数通过URL传递，POST放在Request body中。

`GET`会产生一个`TCP`数据包，而`POST`会产生两个`TCP`数据包。

详细的说就是：

- 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200(返回数据);
- 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。



### 请求报头

请求报头允许客户端向服务器传递请求的附加信息和客户端自身的信息。



### 请求正文

当使用POST, PUT等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中。在请求包头中有一些与请求正文相关的信息，例如: 现在的Web应用通常采用Rest架构，请求的数据格式一般为json。这时就需要设置`Content-Type: application/json`。



### 强缓存、协商缓存

#### 强缓存

当向浏览器发起资源请求时，查询是否命中强缓存，若命中则直接使用缓存资源不再发起请求。

通过http头信息中`Expire`属性和`Cache-control`属性。

* 服务器通过在响应头添加Expire属性，指定资源的过期时间。（该时间为绝对时间，因此可能存在与客户端时间不一致或客户端修改时间的问题）
* http1.1 提出Cache-control属性。常用属性：max-age：资源最大存储时间（为相对时间，根据该时间和第一次请求时间计算得出过期时间）；private:只能被客户端缓存，代理服务器无法缓存；no-store，指定资源不能缓存；no-cache:能缓存但立即失效。
* 一起使用是cache-control优先级更高

#### 协商缓存

先向服务端发送一个请求，若资源没有修改则返回304状态码，让浏览器使用本地缓存副本。

通过`Etag`和`Last-Modified`设置

* 服务端指定`Last-Modified`指出最后修改时间，浏览器下一次发起请求时，会在请求头添加`If-Modified-Since`属性，属性值为上次返回时的`Last-Modified`。请求发送到服务端时进行比较，判断是否资源已修改。若未修改返回304状态码，已修改则返回资源（缺点：只能精确到秒级。若1s内多次修改会导致不准确）
* 服务器返回资源时，头信息中添加`Etag`属性，是资源生成的唯一标识符，资源发生改变，该值改变。下次请求时，浏览器在请求头添加`If-None-Match`属性，为上次返回资源的`Etag`值。服务端进行比较判断。
* `Etag`优先级更高

## 服务器处理请求并返回HTTP报文

### 状态码

状态码是由3位数组成，第一个数字定义了响应的类别，且有五种可能取值:

- 1xx：指示信息–表示请求已接收，继续处理。
- 2xx：成功–表示请求已被成功接收、理解、接受。
- 3xx：重定向–要完成请求必须进行更进一步的操作。
- 4xx：客户端错误–请求有语法错误或请求无法实现。
- 5xx：服务器端错误–服务器未能实现合法的请求。 平时遇到比较常见的状态码有:200, 204, 301, 302, 304, 400, 401, 403, 404, 422, 500

#### 常见状态码区别

`200 成功`

请求成功，通常服务器提供了需要的资源。

`204 无内容`

服务器成功处理了请求，但没有返回任何内容。

`301 永久移动`

请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。

`302 临时移动`

服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。

`304 未修改`

自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。

`400 错误请求`

服务器不理解请求的语法。

` 401 未授权`

请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。

` 403 禁止`

服务器拒绝请求。

`404 未找到`

服务器找不到请求的网页。

`422 无法处理`

请求格式正确，但是由于含有语义错误，无法响应

`500 服务器内部错误`

服务器遇到错误，无法完成请求。



## 浏览器解析渲染页面

* 解析HTML形成DOM树

* 解析CSS形成CSSOM 树

* 合并DOM树和CSSOM树形成渲染树

* 浏览器开始渲染并绘制页面 这个过程涉及两个比较重要的概念**回流**和**重绘**，DOM结点都是以盒模型形式存在，需要浏览器去计算位置和宽度等，这个过程就是回流。等到页面的宽高，大小，颜色等属性确定下来后，浏览器开始绘制内容，这个过程叫做重绘。浏览器刚打开页面一定要经过这两个过程的，但是这个过程非常非常非常消耗性能，所以我们应该尽量减少页面的回流和重绘



### 性能优化之回流重绘

#### 回流

当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。

会导致回流的操作：

- 页面首次渲染
- 浏览器窗口大小发生改变
- 元素尺寸或位置发生改变
- 元素内容变化（文字数量或图片大小等等）
- 元素字体大小变化
- 添加或者删除可见的DOM元素
- 激活CSS伪类（例如：:hover）
- 查询某些属性或调用某些方法

一些常用且会导致回流的属性和方法：

- `clientWidth、clientHeight、clientTop、clientLeft`
- `offsetWidth、offsetHeight、offsetTop、offsetLeft`
- `scrollWidth、scrollHeight、scrollTop、scrollLeft`
- `scrollIntoView()、scrollIntoViewIfNeeded()`
- `getComputedStyle()`
- `getBoundingClientRect()`
- `scrollTo()`

#### 重绘

当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。

#### 优化

##### CSS

- 避免使用table布局。
- 尽可能在DOM树的最末端改变class。
- 避免设置多层内联样式。
- 将动画效果应用到position属性为absolute或fixed的元素上。
- 避免使用CSS表达式（例如：calc()）。

##### JavaScript

- 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。
- 避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。
- 也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。
- 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。
- 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。

