## 进程和线程
进程 cpu资源分配的最小单位，进程之间相互独立（可大代价实现通信）
线程 cpu调度的最小单位，进程的基础上运行，一个进程可有多个线程

## 网络协议
### TCP/IP三次握手四次挥手
三次握手：
* 客户端向服务端发送SYN报文,并指明初始化序列号ISN，客户端closed->SYN-SENT状态
* 服务端接收到客户端SYN报文后，返回自己的SYN报文，并指定自己的ISN，同时将客户端的ISN+1作为ACK返回客户端，表示自己收到了客户端的SYN，服务器从listen->SYN-RCVD
* 客户端接收到SYN报文后，发送ACK报文，表示收到客户端的SYN，客户端进入ESTABLISHED状态，服务端收到ACK报文后，也处于ESTABLISED状态，双方建立连接

四次挥手：
* 第一次 客户端发送FIN报文，报文中指定一个序列号，客户端进入FIN-WAIT-1状态。这是客户端同时也变成了half-close状态，即无法向服务端发送报文，只能接受。
* 第二次 服务端接收到FIN报文，会发送ACK报文，且把接受到的序列号+1作为ACK报文的序列号值，表示接受到报文，服务器进入CLOSE_WAIT状态，通知自身关闭连接
* 客户端接收到服务端的ACK，进入FIN-WAIT-2状态
* 第三次 如果服务端也想断开连接了，和客户端第一次挥手一样，发送FIN报文，且指定一个序列号。服务端进入LAST-ACK状态
* 第四次 客户端接收到FIN，一样发送ACK报文作为应答，此时客户端进入TIME-WAIT状态

此时客户端等待2个MSL（最大报文生存时间），这段时间内如果客户端没有接受到服务端的重发请求，表示ACK成功到达，挥手结束，否则服务端重发ACK

1. 为什么要三次握手，两次呢？
  两次握手，服务端不能确定客户端的接收能力

2. 半连接队列？
  服务器端第一次接受到客户端的SYN请求，就会处于SYN-RCVD状态，此时双方没有完全建立连接，服务器会把此种状态下请求连接放在一个队列中，称为半连接队列。

3. SYN攻击？
